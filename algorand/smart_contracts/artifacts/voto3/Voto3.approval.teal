#pragma version 10
#pragma typetrack false

// smart_contracts.voto3.contract.Voto3.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 4 3
    bytecblock "estado_contrato" 0x151f7c75 "papeletas" "contador_compromisos" "contador_raices" "contador_anuladores" "papeletas_enviadas" "num_bloques" "tam_bloque" "tam_resto" "txnId_raiz"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/voto3/contract.py:38
    // self.estado_contrato = UInt64(0)
    bytec_0 // "estado_contrato"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:40
    // self.papeletas = Asset(0)
    bytec_2 // "papeletas"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:41
    // self.papeletas_enviadas = UInt64(0)
    bytec 6 // "papeletas_enviadas"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:43
    // self.contador_compromisos = UInt64(0)
    bytec_3 // "contador_compromisos"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:44
    // self.contador_raices = UInt64(0)
    bytec 4 // "contador_raices"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:45
    // self.contador_anuladores = UInt64(0)
    bytec 5 // "contador_anuladores"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:47
    // self.num_bloques = UInt64(0)
    bytec 7 // "num_bloques"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:48
    // self.tam_bloque = UInt64(0)
    bytec 8 // "tam_bloque"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:49
    // self.tam_resto = UInt64(0)
    bytec 9 // "tam_resto"
    intc_0 // 0
    app_global_put
    // smart_contracts/voto3/contract.py:51
    // self.txnId_raiz = String("")
    bytec 10 // "txnId_raiz"
    pushbytes ""
    app_global_put

main_after_if_else@2:
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@21
    pushbytess 0x7757ddca 0x3a97786b 0x894b0b9e 0xc7fe93c0 0x109b6a61 0x88029dd2 0xd330fd1c 0x9c17a430 0x02a28ad5 0x7d9b3e58 0x4e812cf7 0xb9bdcec1 0x69edae75 0x800678ec 0x1ed53243 0x6f163fc9 // method "inicializar_eleccion(string,string,uint64)uint64", method "leer_estado_contrato()uint64", method "establecer_estado_contrato(uint64)uint64", method "abrir_registro_compromisos()void", method "registrar_compromiso()uint64", method "cerrar_registro_compromisos()uint64", method "abrir_registro_raices(uint64,uint64,uint64)void", method "registrar_raiz()uint64", method "cerrar_registro_raices(string)uint64", method "leer_datos_raices()(uint64,uint64,uint64,string)", method "abrir_registro_anuladores()void", method "registrar_anulador()uint64", method "enviar_papeleta(byte[])uint64", method "cerrar_registro_anuladores()uint64", method "recuperar_papeletas(byte[])void", method "finalizar_eleccion()void"
    txna ApplicationArgs 0
    match main_inicializar_eleccion_route@5 main_leer_estado_contrato_route@6 main_establecer_estado_contrato_route@7 main_abrir_registro_compromisos_route@8 main_registrar_compromiso_route@9 main_cerrar_registro_compromisos_route@10 main_abrir_registro_raices_route@11 main_registrar_raiz_route@12 main_cerrar_registro_raices_route@13 main_leer_datos_raices_route@14 main_abrir_registro_anuladores_route@15 main_registrar_anulador_route@16 main_enviar_papeleta_route@17 main_cerrar_registro_anuladores_route@18 main_recuperar_papeletas_route@19 main_finalizar_eleccion_route@20

main_after_if_else@23:
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    intc_0 // 0
    return

main_finalizar_eleccion_route@20:
    // smart_contracts/voto3/contract.py:260
    // @abimethod(allow_actions=["NoOp"])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub finalizar_eleccion
    intc_1 // 1
    return

main_recuperar_papeletas_route@19:
    // smart_contracts/voto3/contract.py:245
    // @abimethod(allow_actions=["NoOp"])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/voto3/contract.py:245
    // @abimethod(allow_actions=["NoOp"])
    callsub recuperar_papeletas
    intc_1 // 1
    return

main_cerrar_registro_anuladores_route@18:
    // smart_contracts/voto3/contract.py:232
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub cerrar_registro_anuladores
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_enviar_papeleta_route@17:
    // smart_contracts/voto3/contract.py:211
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/voto3/contract.py:211
    // @abimethod()
    callsub enviar_papeleta
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_registrar_anulador_route@16:
    // smart_contracts/voto3/contract.py:199
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub registrar_anulador
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_abrir_registro_anuladores_route@15:
    // smart_contracts/voto3/contract.py:188-189
    // # Métodos para anuladores
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub abrir_registro_anuladores
    intc_1 // 1
    return

main_leer_datos_raices_route@14:
    // smart_contracts/voto3/contract.py:179
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub leer_datos_raices
    uncover 3
    itob
    uncover 3
    itob
    uncover 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    pushbytes 0x001a
    concat
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_cerrar_registro_raices_route@13:
    // smart_contracts/voto3/contract.py:167
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/voto3/contract.py:167
    // @abimethod()
    callsub cerrar_registro_raices
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_registrar_raiz_route@12:
    // smart_contracts/voto3/contract.py:155
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub registrar_raiz
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_abrir_registro_raices_route@11:
    // smart_contracts/voto3/contract.py:140
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/voto3/contract.py:140
    // @abimethod()
    callsub abrir_registro_raices
    intc_1 // 1
    return

main_cerrar_registro_compromisos_route@10:
    // smart_contracts/voto3/contract.py:127
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub cerrar_registro_compromisos
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_registrar_compromiso_route@9:
    // smart_contracts/voto3/contract.py:115
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub registrar_compromiso
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_abrir_registro_compromisos_route@8:
    // smart_contracts/voto3/contract.py:105
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub abrir_registro_compromisos
    intc_1 // 1
    return

main_establecer_estado_contrato_route@7:
    // smart_contracts/voto3/contract.py:95
    // @abimethod(allow_actions=["NoOp"])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/voto3/contract.py:95
    // @abimethod(allow_actions=["NoOp"])
    callsub establecer_estado_contrato
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_leer_estado_contrato_route@6:
    // smart_contracts/voto3/contract.py:88
    // @abimethod(allow_actions=["NoOp"])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub leer_estado_contrato
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_inicializar_eleccion_route@5:
    // smart_contracts/voto3/contract.py:55
    // @abimethod(allow_actions=["NoOp"])
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    // smart_contracts/voto3/contract.py:55
    // @abimethod(allow_actions=["NoOp"])
    callsub inicializar_eleccion
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@21:
    // smart_contracts/voto3/contract.py:18
    // class Voto3(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@23
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.voto3.contract.Voto3.inicializar_eleccion(asset_name: bytes, unit_name: bytes, total: uint64) -> uint64:
inicializar_eleccion:
    // smart_contracts/voto3/contract.py:55-61
    // @abimethod(allow_actions=["NoOp"])
    // def inicializar_eleccion(
    //     self,
    //     asset_name: String,
    //     unit_name: String,
    //     total: UInt64,
    // ) -> UInt64:
    proto 3 1
    // smart_contracts/voto3/contract.py:63
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:62-64
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede inicializar la elección"
    assert // Solo el creador puede inicializar la elección
    // smart_contracts/voto3/contract.py:65
    // assert self.estado_contrato == UInt64(0), "El contrato ya está inicializado"
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    !
    assert // El contrato ya está inicializado
    // smart_contracts/voto3/contract.py:70
    // assert name_bytes.length <= 32, "asset_name demasiado largo"
    frame_dig -3
    len
    pushint 32 // 32
    <=
    assert // asset_name demasiado largo
    // smart_contracts/voto3/contract.py:71
    // assert unit_bytes.length <= 8, "unit_name demasiado largo"
    frame_dig -2
    len
    pushint 8 // 8
    <=
    assert // unit_name demasiado largo
    // smart_contracts/voto3/contract.py:73-80
    // asset_txn = itxn.AssetConfig(
    //     asset_name=name_bytes,
    //     unit_name=unit_bytes,
    //     total=total,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     clawback=Global.current_application_address,
    // ).submit()
    itxn_begin
    // smart_contracts/voto3/contract.py:78
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/voto3/contract.py:79
    // clawback=Global.current_application_address,
    dup
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetManager
    // smart_contracts/voto3/contract.py:77
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    frame_dig -1
    itxn_field ConfigAssetTotal
    frame_dig -2
    itxn_field ConfigAssetUnitName
    frame_dig -3
    itxn_field ConfigAssetName
    // smart_contracts/voto3/contract.py:73
    // asset_txn = itxn.AssetConfig(
    intc_3 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/voto3/contract.py:73-80
    // asset_txn = itxn.AssetConfig(
    //     asset_name=name_bytes,
    //     unit_name=unit_bytes,
    //     total=total,
    //     decimals=0,
    //     manager=Global.current_application_address,
    //     clawback=Global.current_application_address,
    // ).submit()
    itxn_submit
    // smart_contracts/voto3/contract.py:82
    // self.papeletas = asset_txn.created_asset
    bytec_2 // "papeletas"
    itxn CreatedAssetID
    app_global_put
    // smart_contracts/voto3/contract.py:83
    // self.estado_contrato = UInt64(1)
    bytec_0 // "estado_contrato"
    intc_1 // 1
    app_global_put
    // smart_contracts/voto3/contract.py:84
    // return self.papeletas.id
    intc_0 // 0
    bytec_2 // "papeletas"
    app_global_get_ex
    assert // check self.papeletas exists
    retsub


// smart_contracts.voto3.contract.Voto3.leer_estado_contrato() -> uint64:
leer_estado_contrato:
    // smart_contracts/voto3/contract.py:91
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:90-92
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede leer el estado del contrato"
    assert // Solo el creador puede leer el estado del contrato
    // smart_contracts/voto3/contract.py:93
    // return self.estado_contrato
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    retsub


// smart_contracts.voto3.contract.Voto3.establecer_estado_contrato(nuevo_estado: uint64) -> uint64:
establecer_estado_contrato:
    // smart_contracts/voto3/contract.py:95-96
    // @abimethod(allow_actions=["NoOp"])
    // def establecer_estado_contrato(self, nuevo_estado: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/voto3/contract.py:98
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:97-99
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede establecer el estado del contrato"
    assert // Solo el creador puede establecer el estado del contrato
    // smart_contracts/voto3/contract.py:100
    // self.estado_contrato = nuevo_estado
    bytec_0 // "estado_contrato"
    frame_dig -1
    app_global_put
    // smart_contracts/voto3/contract.py:101
    // return self.estado_contrato
    frame_dig -1
    retsub


// smart_contracts.voto3.contract.Voto3.abrir_registro_compromisos() -> void:
abrir_registro_compromisos:
    // smart_contracts/voto3/contract.py:108
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:107-109
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede abrir el registro de compromisos"
    assert // Solo el creador puede abrir el registro de compromisos
    // smart_contracts/voto3/contract.py:110
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:110-112
    // assert self.estado_contrato == UInt64(
    //     1
    // ), "El contrato no está en el estado correcto"
    intc_1 // 1
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:113
    // self.estado_contrato = UInt64(2)
    bytec_0 // "estado_contrato"
    pushint 2 // 2
    app_global_put
    retsub


// smart_contracts.voto3.contract.Voto3.registrar_compromiso() -> uint64:
registrar_compromiso:
    // smart_contracts/voto3/contract.py:118
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:117-119
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede registrar compromisos"
    assert // Solo el creador puede registrar compromisos
    // smart_contracts/voto3/contract.py:120
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:120-122
    // assert self.estado_contrato == UInt64(
    //     2
    // ), "El contrato no está en el estado correcto"
    pushint 2 // 2
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:123
    // valor_actual = self.contador_compromisos
    intc_0 // 0
    bytec_3 // "contador_compromisos"
    app_global_get_ex
    assert // check self.contador_compromisos exists
    // smart_contracts/voto3/contract.py:124
    // self.contador_compromisos = valor_actual + 1
    intc_1 // 1
    +
    bytec_3 // "contador_compromisos"
    dig 1
    app_global_put
    // smart_contracts/voto3/contract.py:125
    // return self.contador_compromisos
    retsub


// smart_contracts.voto3.contract.Voto3.cerrar_registro_compromisos() -> uint64:
cerrar_registro_compromisos:
    // smart_contracts/voto3/contract.py:130
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:129-131
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede cerrar el registro de compromisos"
    assert // Solo el creador puede cerrar el registro de compromisos
    // smart_contracts/voto3/contract.py:132
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:132-134
    // assert self.estado_contrato == UInt64(
    //     2
    // ), "El contrato no está en el estado correcto"
    pushint 2 // 2
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:135
    // self.estado_contrato = UInt64(3)
    bytec_0 // "estado_contrato"
    intc_3 // 3
    app_global_put
    // smart_contracts/voto3/contract.py:136
    // return self.contador_compromisos
    intc_0 // 0
    bytec_3 // "contador_compromisos"
    app_global_get_ex
    assert // check self.contador_compromisos exists
    retsub


// smart_contracts.voto3.contract.Voto3.abrir_registro_raices(num_bloques: uint64, tam_bloque: uint64, tam_resto: uint64) -> void:
abrir_registro_raices:
    // smart_contracts/voto3/contract.py:140-143
    // @abimethod()
    // def abrir_registro_raices(
    //     self, num_bloques: UInt64, tam_bloque: UInt64, tam_resto: UInt64
    // ) -> None:
    proto 3 0
    // smart_contracts/voto3/contract.py:145
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:144-146
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede abrir el registro de raíces"
    assert // Solo el creador puede abrir el registro de raíces
    // smart_contracts/voto3/contract.py:147
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:147-149
    // assert self.estado_contrato == UInt64(
    //     3
    // ), "El contrato no está en el estado correcto"
    intc_3 // 3
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:150
    // self.num_bloques = num_bloques
    bytec 7 // "num_bloques"
    frame_dig -3
    app_global_put
    // smart_contracts/voto3/contract.py:151
    // self.tam_bloque = tam_bloque
    bytec 8 // "tam_bloque"
    frame_dig -2
    app_global_put
    // smart_contracts/voto3/contract.py:152
    // self.tam_resto = tam_resto
    bytec 9 // "tam_resto"
    frame_dig -1
    app_global_put
    // smart_contracts/voto3/contract.py:153
    // self.estado_contrato = UInt64(4)
    bytec_0 // "estado_contrato"
    intc_2 // 4
    app_global_put
    retsub


// smart_contracts.voto3.contract.Voto3.registrar_raiz() -> uint64:
registrar_raiz:
    // smart_contracts/voto3/contract.py:158
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:157-159
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede registrar raíces"
    assert // Solo el creador puede registrar raíces
    // smart_contracts/voto3/contract.py:160
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:160-162
    // assert self.estado_contrato == UInt64(
    //     4
    // ), "El contrato no está en el estado correcto"
    intc_2 // 4
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:163
    // valor_actual = self.contador_raices
    intc_0 // 0
    bytec 4 // "contador_raices"
    app_global_get_ex
    assert // check self.contador_raices exists
    // smart_contracts/voto3/contract.py:164
    // self.contador_raices = valor_actual + 1
    intc_1 // 1
    +
    bytec 4 // "contador_raices"
    dig 1
    app_global_put
    // smart_contracts/voto3/contract.py:165
    // return self.contador_raices
    retsub


// smart_contracts.voto3.contract.Voto3.cerrar_registro_raices(txnId_raiz: bytes) -> uint64:
cerrar_registro_raices:
    // smart_contracts/voto3/contract.py:167-168
    // @abimethod()
    // def cerrar_registro_raices(self, txnId_raiz: String) -> UInt64:
    proto 1 1
    // smart_contracts/voto3/contract.py:170
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:169-171
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede cerrar el registro de raíces"
    assert // Solo el creador puede cerrar el registro de raíces
    // smart_contracts/voto3/contract.py:172
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:172-174
    // assert self.estado_contrato == UInt64(
    //     4
    // ), "El contrato no está en el estado correcto"
    intc_2 // 4
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:175
    // self.estado_contrato = UInt64(5)
    bytec_0 // "estado_contrato"
    pushint 5 // 5
    app_global_put
    // smart_contracts/voto3/contract.py:176
    // self.txnId_raiz = txnId_raiz
    bytec 10 // "txnId_raiz"
    frame_dig -1
    app_global_put
    // smart_contracts/voto3/contract.py:177
    // return self.contador_raices
    intc_0 // 0
    bytec 4 // "contador_raices"
    app_global_get_ex
    assert // check self.contador_raices exists
    retsub


// smart_contracts.voto3.contract.Voto3.leer_datos_raices() -> uint64, uint64, uint64, bytes:
leer_datos_raices:
    // smart_contracts/voto3/contract.py:181
    // assert self.estado_contrato >= UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:181-183
    // assert self.estado_contrato >= UInt64(
    //     5
    // ), "El contrato no está en el estado correcto"
    pushint 5 // 5
    >=
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:184
    // return (self.num_bloques, self.tam_bloque, self.tam_resto, self.txnId_raiz)
    intc_0 // 0
    bytec 7 // "num_bloques"
    app_global_get_ex
    assert // check self.num_bloques exists
    intc_0 // 0
    bytec 8 // "tam_bloque"
    app_global_get_ex
    assert // check self.tam_bloque exists
    intc_0 // 0
    bytec 9 // "tam_resto"
    app_global_get_ex
    assert // check self.tam_resto exists
    intc_0 // 0
    bytec 10 // "txnId_raiz"
    app_global_get_ex
    assert // check self.txnId_raiz exists
    retsub


// smart_contracts.voto3.contract.Voto3.abrir_registro_anuladores() -> void:
abrir_registro_anuladores:
    // smart_contracts/voto3/contract.py:192
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:191-193
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede abrir el registro de anuladores"
    assert // Solo el creador puede abrir el registro de anuladores
    // smart_contracts/voto3/contract.py:194
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:194-196
    // assert self.estado_contrato == UInt64(
    //     5
    // ), "El contrato no está en el estado correcto"
    pushint 5 // 5
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:197
    // self.estado_contrato = UInt64(6)
    bytec_0 // "estado_contrato"
    pushint 6 // 6
    app_global_put
    retsub


// smart_contracts.voto3.contract.Voto3.registrar_anulador() -> uint64:
registrar_anulador:
    // smart_contracts/voto3/contract.py:202
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:201-203
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede registrar anuladores"
    assert // Solo el creador puede registrar anuladores
    // smart_contracts/voto3/contract.py:204
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:204-206
    // assert self.estado_contrato == UInt64(
    //     6
    // ), "El contrato no está en el estado correcto"
    pushint 6 // 6
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:207
    // valor_actual = self.contador_anuladores
    intc_0 // 0
    bytec 5 // "contador_anuladores"
    app_global_get_ex
    assert // check self.contador_anuladores exists
    // smart_contracts/voto3/contract.py:208
    // self.contador_anuladores = valor_actual + 1
    intc_1 // 1
    +
    bytec 5 // "contador_anuladores"
    dig 1
    app_global_put
    // smart_contracts/voto3/contract.py:209
    // return self.contador_anuladores
    retsub


// smart_contracts.voto3.contract.Voto3.enviar_papeleta(destinatario: bytes) -> uint64:
enviar_papeleta:
    // smart_contracts/voto3/contract.py:211-212
    // @abimethod()
    // def enviar_papeleta(self, destinatario: Bytes) -> UInt64:
    proto 1 1
    // smart_contracts/voto3/contract.py:214
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:213-215
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede enviar papeletas"
    assert // Solo el creador puede enviar papeletas
    // smart_contracts/voto3/contract.py:216
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:216-218
    // assert self.estado_contrato == UInt64(
    //     6
    // ), "El contrato no está en el estado correcto"
    pushint 6 // 6
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:220-226
    // itxn.AssetTransfer(
    //     xfer_asset=self.papeletas.id,
    //     asset_amount=UInt64(1),
    //     asset_receiver=Account(destinatario),
    //     sender=Global.current_application_address,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/voto3/contract.py:221
    // xfer_asset=self.papeletas.id,
    intc_0 // 0
    bytec_2 // "papeletas"
    app_global_get_ex
    assert // check self.papeletas exists
    // smart_contracts/voto3/contract.py:223
    // asset_receiver=Account(destinatario),
    frame_dig -1
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/voto3/contract.py:224
    // sender=Global.current_application_address,
    global CurrentApplicationAddress
    itxn_field Sender
    frame_dig -1
    itxn_field AssetReceiver
    // smart_contracts/voto3/contract.py:222
    // asset_amount=UInt64(1),
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field XferAsset
    // smart_contracts/voto3/contract.py:220
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    // smart_contracts/voto3/contract.py:225
    // fee=UInt64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/voto3/contract.py:220-226
    // itxn.AssetTransfer(
    //     xfer_asset=self.papeletas.id,
    //     asset_amount=UInt64(1),
    //     asset_receiver=Account(destinatario),
    //     sender=Global.current_application_address,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit
    // smart_contracts/voto3/contract.py:228
    // valor_actual = self.papeletas_enviadas
    intc_0 // 0
    bytec 6 // "papeletas_enviadas"
    app_global_get_ex
    assert // check self.papeletas_enviadas exists
    // smart_contracts/voto3/contract.py:229
    // self.papeletas_enviadas = valor_actual + 1
    intc_1 // 1
    +
    bytec 6 // "papeletas_enviadas"
    dig 1
    app_global_put
    // smart_contracts/voto3/contract.py:230
    // return self.papeletas_enviadas
    retsub


// smart_contracts.voto3.contract.Voto3.cerrar_registro_anuladores() -> uint64:
cerrar_registro_anuladores:
    // smart_contracts/voto3/contract.py:235
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:234-236
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede cerrar el registro de anuladores"
    assert // Solo el creador puede cerrar el registro de anuladores
    // smart_contracts/voto3/contract.py:237
    // assert self.estado_contrato == UInt64(
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    // smart_contracts/voto3/contract.py:237-239
    // assert self.estado_contrato == UInt64(
    //     6
    // ), "El contrato no está en el estado correcto"
    pushint 6 // 6
    ==
    assert // El contrato no está en el estado correcto
    // smart_contracts/voto3/contract.py:240
    // self.estado_contrato = UInt64(7)
    bytec_0 // "estado_contrato"
    pushint 7 // 7
    app_global_put
    // smart_contracts/voto3/contract.py:241
    // return self.contador_anuladores
    intc_0 // 0
    bytec 5 // "contador_anuladores"
    app_global_get_ex
    assert // check self.contador_anuladores exists
    retsub


// smart_contracts.voto3.contract.Voto3.recuperar_papeletas(cuenta: bytes) -> void:
recuperar_papeletas:
    // smart_contracts/voto3/contract.py:245-246
    // @abimethod(allow_actions=["NoOp"])
    // def recuperar_papeletas(self, cuenta: Bytes) -> None:
    proto 1 0
    // smart_contracts/voto3/contract.py:248
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:247-249
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede recuperar papeletas"
    assert // Solo el creador puede recuperar papeletas
    // smart_contracts/voto3/contract.py:250
    // assert self.estado_contrato == UInt64(7), "La elección no ha acabado"
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    pushint 7 // 7
    ==
    assert // La elección no ha acabado
    // smart_contracts/voto3/contract.py:252-258
    // itxn.AssetTransfer(
    //     xfer_asset=self.papeletas.id,
    //     asset_amount=UInt64(1),
    //     asset_receiver=Global.current_application_address,
    //     sender=Account(cuenta),
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/voto3/contract.py:253
    // xfer_asset=self.papeletas.id,
    intc_0 // 0
    bytec_2 // "papeletas"
    app_global_get_ex
    assert // check self.papeletas exists
    // smart_contracts/voto3/contract.py:255
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/voto3/contract.py:256
    // sender=Account(cuenta),
    frame_dig -1
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    frame_dig -1
    itxn_field Sender
    itxn_field AssetReceiver
    // smart_contracts/voto3/contract.py:254
    // asset_amount=UInt64(1),
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field XferAsset
    // smart_contracts/voto3/contract.py:252
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    // smart_contracts/voto3/contract.py:257
    // fee=UInt64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/voto3/contract.py:252-258
    // itxn.AssetTransfer(
    //     xfer_asset=self.papeletas.id,
    //     asset_amount=UInt64(1),
    //     asset_receiver=Global.current_application_address,
    //     sender=Account(cuenta),
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.voto3.contract.Voto3.finalizar_eleccion() -> void:
finalizar_eleccion:
    // smart_contracts/voto3/contract.py:260-261
    // @abimethod(allow_actions=["NoOp"])
    // def finalizar_eleccion(self) -> None:
    proto 0 0
    // smart_contracts/voto3/contract.py:263
    // Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    // smart_contracts/voto3/contract.py:262-264
    // assert (
    //     Txn.sender == Global.creator_address
    // ), "Solo el creador puede finalizar la elección"
    assert // Solo el creador puede finalizar la elección
    // smart_contracts/voto3/contract.py:265
    // assert self.estado_contrato == UInt64(7), "La elección no ha acabado"
    intc_0 // 0
    bytec_0 // "estado_contrato"
    app_global_get_ex
    assert // check self.estado_contrato exists
    pushint 7 // 7
    ==
    assert // La elección no ha acabado
    // smart_contracts/voto3/contract.py:267-275
    // # Destruir el asset (papeletas)
    // itxn.AssetConfig(
    //     config_asset=self.papeletas.id,
    //     manager=Global.zero_address,
    //     reserve=Global.zero_address,
    //     freeze=Global.zero_address,
    //     clawback=Global.zero_address,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/voto3/contract.py:269
    // config_asset=self.papeletas.id,
    intc_0 // 0
    bytec_2 // "papeletas"
    app_global_get_ex
    assert // check self.papeletas exists
    // smart_contracts/voto3/contract.py:270
    // manager=Global.zero_address,
    global ZeroAddress
    // smart_contracts/voto3/contract.py:271-273
    // reserve=Global.zero_address,
    // freeze=Global.zero_address,
    // clawback=Global.zero_address,
    dupn 3
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    itxn_field ConfigAsset
    // smart_contracts/voto3/contract.py:267-268
    // # Destruir el asset (papeletas)
    // itxn.AssetConfig(
    intc_3 // acfg
    itxn_field TypeEnum
    // smart_contracts/voto3/contract.py:274
    // fee=UInt64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/voto3/contract.py:267-275
    // # Destruir el asset (papeletas)
    // itxn.AssetConfig(
    //     config_asset=self.papeletas.id,
    //     manager=Global.zero_address,
    //     reserve=Global.zero_address,
    //     freeze=Global.zero_address,
    //     clawback=Global.zero_address,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit
    // smart_contracts/voto3/contract.py:277-278
    // # Devolver el crédito sobrante al creador del contrato
    // saldo = Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/voto3/contract.py:279
    // min_balance = Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/voto3/contract.py:280
    // excedente = saldo - min_balance
    -
    dup
    // smart_contracts/voto3/contract.py:281
    // if excedente > UInt64(0):
    bz finalizar_eleccion_after_if_else@4
    // smart_contracts/voto3/contract.py:282-286
    // itxn.Payment(
    //     receiver=Global.creator_address,
    //     amount=excedente,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/voto3/contract.py:283
    // receiver=Global.creator_address,
    global CreatorAddress
    frame_dig 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/voto3/contract.py:282
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/voto3/contract.py:285
    // fee=UInt64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/voto3/contract.py:282-286
    // itxn.Payment(
    //     receiver=Global.creator_address,
    //     amount=excedente,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit

finalizar_eleccion_after_if_else@4:
    // smart_contracts/voto3/contract.py:288
    // self.estado_contrato = UInt64(8)
    bytec_0 // "estado_contrato"
    pushint 8 // 8
    app_global_put
    retsub
